#### 常见算法复杂度

一个数组中的元素可以组成哪些数据对，负责度：1/2*O(n^2) -> O(n^2)
```
int[] data = {0, 1, 2, 3, 4};
for(int i=0; i<data.length; i++) {
    for(int j=i+1; j<data.length; j++) {
        // 获取一个数据对 (data[i], data[j])
        // 取到的 i 始终小于 j，复杂度为 1/2*O(n^2)
        // (0, 1) (0, 2) (0, 3) (0, 4)
        // (1, 2) (1, 3) (1, 4)
        // (2, 3) (2, 4)
        // (3, 4)
    }
}
```

---

遍历一个 n * n 的二维数组，n 表示二维数组的某个维度是 n，负责度：O(n^2)
```
for(int i=0; i<n; i++) {
    for(int j=0; j<n; j++) {
        // 遍历到 A[i][j]，复杂度为 O(n^2)
    }
}
```

遍历一个 a * a 的二维数组，其中 a * a = n，n 表示二维数组的元素总个数是 n，复杂度：O(n)
```
for(int i=0; i<a; i++) {
    for(int j=0; j<a; j++) {
        // 遍历到 A[i][j]，复杂度为 O(n)
    }
}
```

---

数字 n 的二进制位数，复杂度：O(logn)
```
while(n) {
    int bit = n % 2; // n 的二进制中的一位
    n /= 2;
}
```

数字 n 的十进制位数，复杂度：O(logn)
```
while(n) {
    int bit = n % 10; // n 的十进制中的一位
    n /= 10;
}
```

对于以上对数级别的复杂度，统称为：O(logn)，忽略掉底数，因为对于对数级别的函数，根据换底公式：logab = logcb/logca，不同底数之间的结果只相差一个常数：logca

---

数字 n 的所有约数
```
for(int i=0; i<n; i++) {
    if (n%i == 0) {
        // i 是 n 的一个约数，复杂度为 O(n)
    }
}
```

根据一个数的所有约数都是成对出现的，可以将以上算法做优化
```
for(int i=0; i*i<n; i++) {
    if (n%i == 0) {
        // i 和 n/i 是 n 的两个约数，复杂度为 O(根号n)
    }
}
```

---

长度为 n 的二进制数字，比如 n = 3，结果为：000 001 010 011 100 101 110 111，根据排列组合公式，复杂度为：O(2^n)，当 n = 100 时，2^n 近乎等于宇宙中所有原子的个数，是增长非常恐怖的一种复杂度

长度为 n 的数组的所有排列，比如 n = 3，结果为：123 132 213 231 312 321，根据全排列公式，复杂度为：O(n!)，阶乘复杂度比指数复杂度增长更快的复杂度，尽量避免指数和阶乘复杂度的算法

---

判断数字 n 是否为偶数，复杂度：O(1)

---

O(1)<O(logn)<O(根号n)<O(n)<O(nlogn)<O(n^2)<O(2^n)<O(n!)












